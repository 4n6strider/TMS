#include <math.h>

//gamma correction, rgb-XYZ-Lab 

//D65 (Daylight)
const double Xn = 95.047;
const double Yn = 100;
const double Zn = 108.883;

const double EPS_8 =1e-8;

const double _third = 1.0 / 3.0;

unsigned char display_clipping(double display_01)
{
//from non-lin display_01 to [0,255]
//clipping examples: -0.01 -> 0 (out of color gamut);  very bright  1.12 -> 255

	double C;

	if(display_01 < 0) display_01 = 0;
	if(display_01 > 1) display_01 = 1;

	C = 0.5 + display_01 * 255.;
	
	return( (unsigned char) C );

}

double display_normalization(unsigned char display)
{
//from [0,255] to [0,1]  (non-lin)

	double C;

	C = (double) display;
	
	return(C / 255.);

}

double Cdisplay_01_Clinear(double Cdisplay)
{
//both are normalized to [0,1]
//default 709 gamma = 2.2

	double Clinear;

	Clinear =  Cdisplay <= 0.081 ?  Cdisplay / 4.5 : 
									pow((Cdisplay + 0.099) / 1.099, 2.2); 

	return(Clinear);

}

//these functions are official standards, but not quite exactly continuous the value and the derivative
//and the inverse of the function, but it works, the error is not visible, and in the dark region
//is significant better than the only power function. It can be corrected...

double Clinear_Cdisplay_01(double Clinear)
{
//both are normalized to [0,1]

	double Cdisplay_01;

	Cdisplay_01 =  Clinear <= 0.018 ?	4.5 * Clinear : 
									-0.099 + 1.099 * pow(Clinear, 0.45); 
	return(Cdisplay_01);								

}

void RGBlinear_RGBdisplay(
	double Rlinear, 
	double Glinear, 
	double Blinear,
	double * Rdisplay,
	double * Gdisplay,
	double * Bdisplay)
{
//it computes from 3 linear double values the 3 clipped and gamma corrected BYTE to displaying
		
	double Rdisplay_01, Gdisplay_01, Bdisplay_01;

		Rdisplay_01 = Clinear_Cdisplay_01(Rlinear);
		//*Rdisplay   = display_clipping(Rdisplay_01);

		Gdisplay_01 = Clinear_Cdisplay_01(Glinear);
		//*Gdisplay   = display_clipping(Gdisplay_01);

		Bdisplay_01 = Clinear_Cdisplay_01(Blinear);
		//*Bdisplay   = display_clipping(Bdisplay_01);

}

double gray_equivalent(unsigned char R, unsigned char G, unsigned char B)
{
// it is useful in the simple color to gray transformation
	
	double r, g, b, Y;

	r = Cdisplay_01_Clinear((double)R/255.0);
	g = Cdisplay_01_Clinear((double)G/255.0);
	b = Cdisplay_01_Clinear((double)B/255.0);

	Y = 0.212671*r + 0.71516*g +  0.072169*b;  

	//Y = 0...1

	return(Y);
}


long CIE_Y_from_L(double L, double * Y)
{
	double y_rel;

	if(L < 0) return(1);

	if(L < 0.008856*903.3)
	   y_rel = L / 903.3;

	else
	   y_rel = pow((L + 16.)/116. , 3.);

	*Y = y_rel * Yn;

	return(0);
}

long Lab_XYZ(double  L,  double a,  double b,
             double  *X, double *Y, double *Z)
{
//============================================
	
	double x_rel, y_rel, z_rel, xx, yy, zz;

	if(L < 0 || Yn < 1E-8) return(1);

	CIE_Y_from_L(L,Y);
	
	y_rel = *Y/Yn;
	yy = pow(y_rel,0.3333333333333);

	xx = a / 500. + yy;
	zz = yy - b / 200.;

	x_rel = pow(xx,3.);
	*X = x_rel * Xn;

	z_rel = pow(zz,3.);
	*Z = z_rel * Zn;

	return(0);
}

void XYZ_RGB709(double X, double Y, double Z,
				double*R, double*G, double*B)
{
// white Y = 100
// white R,G,B = 1,  D65
// [ R709 ] [ 3.240479 -1.53715  -0.498535 ] [ X ] 
// [ G709 ]=[-0.969256  1.875991  0.041556 ]*[ Y ] 
// [ B709 ] [ 0.055648 -0.204043  1.057311 ] [ Z ] 

	*R	=	0.03240479*X - 0.0153715 *Y - 0.00498535*Z;
    *G	=  -0.00969256*X + 0.01875991*Y + 0.00041556*Z;
    *B  =   0.00055648*X - 0.00204043*Y + 0.01057311*Z;

}

void RGB709_XYZ(double R, double G, double B,
				double*X, double*Y, double*Z)
{
// white Y = 100
// white R,G,B = 1,  D65
// [ X ] [ 0.412453  0.35758   0.180423 ] [ R709 ] 
// [ Y ]=[ 0.212671  0.71516   0.072169 ]*[ G709 ] 
// [ Z ] [ 0.019334  0.119193  0.950227 ] [ B709 ] 

	*X = 41.2453*R + 35.758 *G + 18.0423*B;
	*Y = 21.2671*R + 71.516 *G +  7.2169*B;
    *Z =  1.9334*R + 11.9193*G + 95.0227*B;

}

long CIE_L_from_Y(double Y, double Yn, double * L)
{
//================================================
    double y_rel;

    //0 <= y_rel = Y/Yn <= 100
    //hier permitted y_rel > 1

    if(Y < 0 || Yn < EPS_8) return(0);

    y_rel = Y / Yn;

    if(y_rel < 0.008856)
            *L = 903.3 * y_rel;
    else
            *L = 116. * pow(y_rel,_third) - 16.;

    return(1);
}

unsigned char XYZ_Lab_(double  X,  double Y,  double Z,
              double  Xn, double Yn, double Zn,
              double *L,  double *a, double *b)
{

    double x_rel, y_rel, z_rel, xx, yy, zz;

    if(Xn < EPS_8 || Yn < EPS_8 || Zn < EPS_8) return(0);
    //bad values for nominally white

    if(CIE_L_from_Y(Y,Yn,L) == 0) return(0);
    //Y < 0 || Yn < EPS_8

    x_rel = X/Xn;
    y_rel = Y/Yn;
    z_rel = Z/Zn;

    xx = pow(x_rel,_third);
    yy = pow(y_rel,_third);
    zz = pow(z_rel,_third);

    *a = 500. * (xx - yy);
    *b = 200. * (yy - zz);

    return(1);
}

